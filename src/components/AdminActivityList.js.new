import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  FlatList,
  RefreshControl,
  SectionList,
  Button,
  Linking,
  Dimensions,
  Modal,
  SafeAreaView,
  ScrollView
} from 'react-native';
import MapView, { Marker } from 'react-native-maps';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Ionicons } from '@expo/vector-icons';
import * as api from '../services/api';
import { useLanguage } from '../context/LanguageContext';
import { useTheme } from '../context/ThemeContext';
import { formatDistanceToNow } from 'date-fns';
import { es, enUS } from 'date-fns/locale';

const { width, height } = Dimensions.get('window');

const AdminActivityList = () => {
  const { t } = useLanguage();
  const theme = useTheme();
  const [activities, setActivities] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [refreshing, setRefreshing] = useState(false);
  const [pagination, setPagination] = useState({
    currentPage: 1,
    pages: 1,
    total: 0
  });
  const [filterType, setFilterType] = useState('all');
  const [viewMode, setViewMode] = useState('list');
  const [mapModalVisible, setMapModalVisible] = useState(false);
  const [selectedCoordinates, setSelectedCoordinates] = useState(null);
  const [timeFilter, setTimeFilter] = useState(null); // Filtro de tiempo (rango de horas)

  // Opciones de horas disponibles para filtrar
  const hourRanges = [
    { label: 'Todas las horas', value: null },
    { label: '7-8 AM', value: { start: 7, end: 8 } },
    { label: '8-9 AM', value: { start: 8, end: 9 } },
    { label: '9-10 AM', value: { start: 9, end: 10 } },
    { label: '10-11 AM', value: { start: 10, end: 11 } },
    { label: '11-12 PM', value: { start: 11, end: 12 } },
    { label: '12-1 PM', value: { start: 12, end: 13 } },
    { label: '1-2 PM', value: { start: 13, end: 14 } },
    { label: '2-3 PM', value: { start: 14, end: 15 } },
    { label: '3-4 PM', value: { start: 15, end: 16 } },
    { label: '4-5 PM', value: { start: 16, end: 17 } },
    { label: '5-6 PM', value: { start: 17, end: 18 } },
    { label: '6-7 PM', value: { start: 18, end: 19 } },
  ];

  // Cargar las actividades
  const loadActivities = async (page = 1) => {
    try {
      setLoading(true);
      
      // Obtener el token de autenticación
      const token = await AsyncStorage.getItem('token');
      if (!token) {
        throw new Error('No hay token de autenticación disponible');
      }
      
      // Usar el endpoint CORRECTO para administradores
      const url = `${api.getApiUrl()}/api/activities/admin/all?page=${page}&limit=100`;
      console.log(`Obteniendo actividades de administrador desde: ${url}`);
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error('Error en respuesta de actividades:', errorData);
        throw new Error(errorData.message || `Error ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log('Datos de actividades recibidos:', data);
      
      // Extraer las actividades del resultado
      const activitiesFromApi = data.activities || [];
      
      if (page === 1) {
        setActivities(activitiesFromApi);
      } else {
        setActivities(prevActivities => [...prevActivities, ...activitiesFromApi]);
      }
      
      // Usar la paginación del servidor si está disponible
      setPagination(data.pagination || {
        currentPage: page,
        pages: Math.ceil((data.total || 0) / 100),
        total: data.total || 0
      });
      
      console.log(`Actividades cargadas: ${activitiesFromApi.length}`);
      
      if (activitiesFromApi.length === 0 && page === 1) {
        setError('No hay actividades disponibles para mostrar');
      } else {
        setError(null);
      }
    } catch (error) {
      console.error('Error loading activities:', error);
      setError(error.message || t('error'));
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Cargar actividades al iniciar
  useEffect(() => {
    loadActivities();
  }, []);

  // Función para refrescar
  const onRefresh = () => {
    setRefreshing(true);
    loadActivities(1);
  };

  // Cargar más actividades (paginación)
  const loadMore = () => {
    if (pagination.currentPage < pagination.pages && !loading) {
      loadActivities(pagination.currentPage + 1);
    }
  };

  // Formatear fecha y hora
  const formatDateTime = (dateString) => {
    try {
      const date = new Date(dateString);
      return date.toLocaleString('es-ES', { 
        day: '2-digit', 
        month: '2-digit', 
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch (error) {
      console.error('Error formatting date time:', error);
      return dateString || 'Fecha desconocida';
    }
  };

  // Formatear solo la fecha
  const formatDate = (dateString) => {
    try {
      const date = new Date(dateString);
      return date.toLocaleDateString('es-ES', { 
        day: '2-digit', 
        month: '2-digit', 
        year: 'numeric'
      });
    } catch (error) {
      console.error('Error formatting date:', error);
      return dateString || 'Fecha desconocida';
    }
  };

  // Formatear solo la hora
  const formatTime = (dateString) => {
    try {
      const date = new Date(dateString);
      return date.toLocaleTimeString('es-ES', { 
        hour: '2-digit', 
        minute: '2-digit'
      });
    } catch (error) {
      console.error('Error formatting time:', error);
      return '';
    }
  };

  // Formatear tiempo relativo
  const formatRelativeTime = (dateString) => {
    try {
      const date = new Date(dateString);
      const now = new Date();
      
      // Si la fecha es de hoy, mostrar "Hoy a las HH:MM"
      if (date.toDateString() === now.toDateString()) {
        return `Hoy a las ${formatTime(dateString)}`;
      }
      
      // Si no, usar format-distance-to-now
      return formatDistanceToNow(date, { 
        addSuffix: true,
        locale: t('locale') === 'es' ? es : enUS
      });
    } catch (error) {
      console.error('Error formatting relative time:', error);
      return dateString || 'Fecha desconocida';
    }
  };

  // Obtener el icono según el tipo de actividad
  const getActivityIcon = (type) => {
    switch (type) {
      case 'location_enter':
        return 'enter-outline';
      case 'location_exit':
        return 'exit-outline';
      case 'location_check':
        return 'location-outline';
      case 'task_complete':
        return 'checkmark-circle-outline';
      case 'task_create':
        return 'add-circle-outline';
      case 'task_update':
        return 'create-outline';
      case 'task_delete':
        return 'trash-outline';
      case 'started_working':
      case 'clock_in':
        return 'play-circle-outline';
      case 'stopped_working':
      case 'clock_out':
        return 'stop-circle-outline';
      default:
        return 'information-circle-outline';
    }
  };

  // Obtener color según el tipo de actividad
  const getActivityColor = (type) => {
    switch (type) {
      case 'location_enter':
        return '#4caf50'; // Verde
      case 'location_exit':
        return '#f44336'; // Rojo
      case 'location_check':
        return '#42a5f5'; // Azul claro
      case 'task_complete':
        return '#2196f3'; // Azul
      case 'task_create':
        return '#9c27b0'; // Púrpura
      case 'task_update':
        return '#ff9800'; // Naranja
      case 'task_delete':
        return '#795548'; // Marrón
      case 'started_working':
      case 'clock_in':
        return '#4CAF50'; // Verde
      case 'stopped_working':
      case 'clock_out':
        return '#FF5722'; // Naranja rojizo
      default:
        return '#607d8b'; // Gris azulado
    }
  };

  // Obtener texto descriptivo según el tipo de actividad
  const getActivityTypeText = (type) => {
    switch (type) {
      case 'clock_in':
        return 'Entrada';
      case 'clock_out':
        return 'Salida';
      case 'started_working':
        return 'Inicio de trabajo';
      case 'stopped_working':
        return 'Fin de trabajo';
      case 'task_create':
        return 'Creación de tarea';
      case 'task_update':
        return 'Actualización de tarea';
      case 'task_complete':
        return 'Tarea completada';
      case 'task_delete':
        return 'Tarea eliminada';
      case 'location_enter':
        return 'Entrada a ubicación';
      case 'location_exit':
        return 'Salida de ubicación';
      case 'location_check':
        return 'Punto de seguimiento';
      default:
        return 'Actividad';
    }
  };

  // Generar una descripción detallada de la actividad
  const getDetailedDescription = (item) => {
    const { type, metadata, taskId, userId } = item;
    
    // Nombre de usuario para mostrar
    let userName = '';
    if (typeof userId === 'object' && userId?.username) {
      userName = userId.username;
    }
    
    switch (type) {
      case 'task_create':
        if (metadata && metadata.title) {
          return `Creó la tarea "${metadata.title}"`;
        }
        return 'Creó una tarea';
        
      case 'task_update':
        if (metadata && metadata.title) {
          return `Actualizó la tarea "${metadata.title}"`;
        }
        return 'Actualizó una tarea';
        
      case 'task_complete':
        if (metadata && metadata.title) {
          return `Completó la tarea "${metadata.title}"`;
        }
        return 'Completó una tarea';
        
      case 'task_delete':
        if (metadata && metadata.title) {
          return `Eliminó la tarea "${metadata.title}"`;
        }
        return 'Eliminó una tarea';
        
      case 'location_enter':
        if (metadata && metadata.locationName) {
          return `Entró en ${metadata.locationName}`;
        }
        return 'Entró en una ubicación';
        
      case 'location_exit':
        if (metadata && metadata.locationName) {
          return `Salió de ${metadata.locationName}`;
        }
        return 'Salió de una ubicación';
        
      case 'location_check':
        if (metadata && metadata.latitude && metadata.longitude) {
          return `Punto de seguimiento en coordenadas: ${metadata.latitude.toFixed(6)}, ${metadata.longitude.toFixed(6)}`;
        }
        return 'Punto de seguimiento';
        
      case 'clock_in':
        return 'Marcó entrada';
        
      case 'clock_out':
        return 'Marcó salida';
        
      case 'started_working':
        return 'Comenzó a trabajar';
        
      case 'stopped_working':
        if (metadata && metadata.duration) {
          return `Marcó como no disponible (duración: ${Math.floor(metadata.duration / 60)} min)`;
        } else if (metadata && metadata.latitude && metadata.longitude) {
          return `Marcó como no disponible en coordenadas: ${metadata.latitude.toFixed(6)}, ${metadata.longitude.toFixed(6)}`;
        }
        return 'Marcó como no disponible';
        
      default:
        return 'Actividad registrada';
    }
  };

  // Filtrar actividades por tipo y tiempo
  const getFilteredActivities = () => {
    // Primero, filtramos los location_check de la vista general
    let filteredActivities = activities;
    if (filterType !== 'location') {
      // Si no estamos en el filtro de ubicación, excluimos los location_check
      filteredActivities = activities.filter(activity => activity.type !== 'location_check');
    }
    
    // Si estamos en la vista general (sin filtro específico), retornamos todo excepto location_check
    if (filterType === 'all') {
      return filteredActivities;
    }
    
    // Aplicar filtros específicos por tipo
    filteredActivities = filteredActivities.filter(activity => {
      const { type } = activity;
      
      if (filterType === 'availability') {
        return ['clock_in', 'clock_out', 'started_working', 'stopped_working'].includes(type);
      }
      
      if (filterType === 'task') {
        return ['task_create', 'task_update', 'task_complete', 'task_delete'].includes(type);
      }
      
      if (filterType === 'location') {
        return ['location_check'].includes(type);
      }
      
      return true;
    });
    
    // Aplicar filtro de tiempo si está activo y estamos en filtro de ubicación
    if (filterType === 'location' && timeFilter) {
      filteredActivities = filteredActivities.filter(activity => {
        // Obtener la hora del evento
        const activityDate = new Date(activity.createdAt || activity.timestamp);
        const activityHour = activityDate.getHours();
        
        // Verificar si la hora está dentro del rango seleccionado
        return activityHour >= timeFilter.start && activityHour < timeFilter.end;
      });
    }
    
    return filteredActivities;
  };

  // Agrupar actividades por usuario
  const getGroupedActivities = () => {
    const filtered = getFilteredActivities();
    const grouped = {};
    
    filtered.forEach((activity) => {
      let userKey = 'unknown';
      let userName = 'Usuario desconocido';
      
      if (typeof activity.userId === 'object' && activity.userId?.username) {
        userKey = activity.userId._id || 'unknown';
        userName = activity.userId.username;
      } else if (typeof activity.userId === 'string') {
        userKey = activity.userId;
        userName = `Usuario ID: ${activity.userId.substring(0, 8)}...`;
      }
      
      if (!grouped[userKey]) {
        grouped[userKey] = {
          title: userName,
          data: [],
        };
      }
      
      grouped[userKey].data.push(activity);
    });
    
    // Convertir el objeto en un array para SectionList
    return Object.values(grouped).sort((a, b) => {
      // Ordenar secciones por nombre de usuario
      return a.title.localeCompare(b.title);
    });
  };

  // Renderizar el modal con mapa
  const renderMapModal = () => {
    if (!selectedCoordinates) return null;
    
    return (
      <Modal
        animationType="fade"
        transparent={true}
        visible={mapModalVisible}
        onRequestClose={() => setMapModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Ubicación</Text>
              <TouchableOpacity onPress={() => setMapModalVisible(false)}>
                <Ionicons name="close" size={24} color="#fff3e5" />
              </TouchableOpacity>
            </View>
            
            <Text style={styles.modalDescription}>{selectedCoordinates.description}</Text>
            <Text style={styles.modalCoordinates}>
              {selectedCoordinates.latitude.toFixed(6)}, {selectedCoordinates.longitude.toFixed(6)}
            </Text>
            <Text style={styles.modalDateTime}>{formatDateTime(selectedCoordinates.timestamp)}</Text>
            
            <MapView
              style={styles.map}
              initialRegion={{
                latitude: selectedCoordinates.latitude,
                longitude: selectedCoordinates.longitude,
                latitudeDelta: 0.005,
                longitudeDelta: 0.005,
              }}
            >
              <Marker
                coordinate={{
                  latitude: selectedCoordinates.latitude,
                  longitude: selectedCoordinates.longitude
                }}
                title={selectedCoordinates.description}
              />
            </MapView>
            
            <TouchableOpacity 
              style={styles.openMapsButton}
              onPress={() => {
                // URL para Apple Maps en iOS
                const url = `http://maps.apple.com/?q=${selectedCoordinates.latitude},${selectedCoordinates.longitude}`;
                Linking.openURL(url);
              }}
            >
              <Text style={styles.openMapsButtonText}>Abrir en Maps</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    );
  };

  // Renderizar un elemento de actividad
  const renderActivityItem = ({ item }) => {
    const { type, createdAt, userId, taskId, metadata, message } = item;
    
    // Obtener nombre de usuario (puede venir de diferentes formas)
    let userName = 'Usuario desconocido';
    if (typeof userId === 'object' && userId?.username) {
      userName = userId.username;
    } else if (typeof userId === 'string') {
      userName = `Usuario ID: ${userId.substring(0, 8)}...`;
    }
    
    // Obtener información de tipo y estilo
    const typeText = getActivityTypeText(type);
    const color = getActivityColor(type);
    const icon = getActivityIcon(type);
    
    // Utilizar el mensaje directamente si existe
    const detailedDescription = message || getDetailedDescription(item);

    // Función para abrir el modal con mapa para location_check
    const handleOpenMap = () => {
      if (metadata && metadata.latitude && metadata.longitude) {
        setSelectedCoordinates({
          latitude: metadata.latitude,
          longitude: metadata.longitude,
          description: detailedDescription,
          timestamp: createdAt || item.timestamp
        });
        setMapModalVisible(true);
      }
    };

    return (
      <View style={styles.activityItem}>
        <View style={[styles.activityIconContainer, { backgroundColor: color }]}>
          <Ionicons name={icon} size={24} color="white" />
        </View>
        
        <View style={styles.activityContent}>
          <View style={styles.activityHeader}>
            <Text style={styles.activityType}>{typeText}</Text>
            <Text style={styles.activityTime}>{formatTime(createdAt || item.timestamp)}</Text>
          </View>
          
          {viewMode === 'list' && (
            <Text style={styles.userName}>{userName}</Text>
          )}
          
          <Text style={styles.activityDescription}>{detailedDescription}</Text>
          
          <Text style={styles.activityDateTime}>{formatDate(createdAt || item.timestamp)}</Text>
          
          {metadata && metadata.duration && (
            <Text style={styles.activityDuration}>
              Duración: {Math.floor(metadata.duration / 60)} minutos
            </Text>
          )}
          
          {/* Botón para ver ubicación en mapa si es una actividad de tipo location_check */}
          {type === 'location_check' && metadata && metadata.latitude && metadata.longitude && (
            <TouchableOpacity 
              style={styles.mapButton}
              onPress={handleOpenMap}
            >
              <Ionicons name="map-outline" size={16} color={theme.colors.lightCream} />
              <Text style={styles.mapButtonText}>Ver en mapa</Text>
            </TouchableOpacity>
          )}
        </View>
      </View>
    );
  };
  
  // Renderizar el encabezado de sección para la vista agrupada
  const renderSectionHeader = ({ section: { title } }) => {
    return (
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionHeaderText}>{title}</Text>
      </View>
    );
  };
  
  // Renderizar el separador entre elementos
  const renderSeparator = () => <View style={styles.separator} />;
  
  // Renderizar los botones de filtro
  const renderFilterButtons = () => {
    return (
      <>
        <View style={styles.filterContainer}>
          <TouchableOpacity
            style={[styles.filterButton, filterType === 'all' && styles.filterButtonActive]}
            onPress={() => {
              setFilterType('all');
              setTimeFilter(null); // Resetear filtro de tiempo
            }}
          >
            <Ionicons
              name="apps-outline"
              size={16}
              color={filterType === 'all' ? '#2e2e2e' : '#fff3e5'}
            />
            <Text
              style={[
                styles.filterButtonText,
                filterType === 'all' && styles.filterButtonTextActive,
              ]}
            >
              {t('all')}
            </Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={[styles.filterButton, filterType === 'availability' && styles.filterButtonActive]}
            onPress={() => {
              setFilterType('availability');
              setTimeFilter(null); // Resetear filtro de tiempo
            }}
          >
            <Ionicons
              name="time-outline"
              size={16}
              color={filterType === 'availability' ? '#2e2e2e' : '#fff3e5'}
            />
            <Text
              style={[
                styles.filterButtonText,
                filterType === 'availability' && styles.filterButtonTextActive,
              ]}
            >
              {t('availability')}
            </Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={[styles.filterButton, filterType === 'task' && styles.filterButtonActive]}
            onPress={() => {
              setFilterType('task');
              setTimeFilter(null); // Resetear filtro de tiempo
            }}
          >
            <Ionicons
              name="checkbox-outline"
              size={16}
              color={filterType === 'task' ? '#2e2e2e' : '#fff3e5'}
            />
            <Text
              style={[
                styles.filterButtonText,
                filterType === 'task' && styles.filterButtonTextActive,
              ]}
            >
              {t('tasks')}
            </Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={[styles.filterButton, filterType === 'location' && styles.filterButtonActive]}
            onPress={() => setFilterType('location')}
          >
            <Ionicons
              name="location-outline"
              size={16}
              color={filterType === 'location' ? '#2e2e2e' : '#fff3e5'}
            />
            <Text
              style={[
                styles.filterButtonText,
                filterType === 'location' && styles.filterButtonTextActive,
              ]}
            >
              {t('location')}
            </Text>
          </TouchableOpacity>
        </View>
        
        {/* Filtro de horas - Solo se muestra cuando el filtro de ubicación está activo */}
        {filterType === 'location' && (
          <View style={styles.timeFilterContainer}>
            <Text style={styles.timeFilterLabel}>Filtrar por hora:</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false}>
              <View style={styles.timeFilterButtonsContainer}>
                {hourRanges.map((range, index) => (
                  <TouchableOpacity
                    key={index}
                    style={[
                      styles.timeFilterButton,
                      (!timeFilter && !range.value) || 
                      (timeFilter && range.value && 
                        timeFilter.start === range.value.start && 
                        timeFilter.end === range.value.end) 
                        ? styles.timeFilterButtonActive 
                        : {}
                    ]}
                    onPress={() => setTimeFilter(range.value)}
                  >
                    <Text 
                      style={[
                        styles.timeFilterButtonText,
                        (!timeFilter && !range.value) || 
                        (timeFilter && range.value && 
                          timeFilter.start === range.value.start && 
                          timeFilter.end === range.value.end) 
                          ? styles.timeFilterButtonTextActive 
                          : {}
                      ]}
                    >
                      {range.label}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </ScrollView>
          </View>
        )}
      </>
    );
  };
  
  // Renderizar los botones de modo de vista
  const renderViewModeButtons = () => {
    return (
      <View style={styles.viewModeContainer}>
        <TouchableOpacity
          style={[styles.viewModeButton, viewMode === 'list' && styles.viewModeButtonActive]}
          onPress={() => setViewMode('list')}
        >
          <Ionicons
            name="list-outline"
            size={16}
            color={viewMode === 'list' ? '#2e2e2e' : '#fff3e5'}
          />
          <Text
            style={[
              styles.viewModeButtonText,
              viewMode === 'list' && styles.viewModeButtonTextActive,
            ]}
          >
            {t('list')}
          </Text>
        </TouchableOpacity>
        
        <TouchableOpacity
          style={[styles.viewModeButton, viewMode === 'grouped' && styles.viewModeButtonActive]}
          onPress={() => setViewMode('grouped')}
        >
          <Ionicons
            name="people-outline"
            size={16}
            color={viewMode === 'grouped' ? '#2e2e2e' : '#fff3e5'}
          />
          <Text
            style={[
              styles.viewModeButtonText,
              viewMode === 'grouped' && styles.viewModeButtonTextActive,
            ]}
          >
            {t('byUser')}
          </Text>
        </TouchableOpacity>
      </View>
    );
  };
  
  // Renderizar el encabezado de la pantalla
  const renderHeader = () => {
    return (
      <View style={styles.header}>
        <Text style={styles.title}>{t('adminActivities')}</Text>
        <Text style={styles.subtitle}>{t('adminActivitiesSubtitle')}</Text>
        
        {renderFilterButtons()}
        {renderViewModeButtons()}
        
        {loading && <ActivityIndicator size="large" color={theme.colors.lightCream} style={styles.loader} />}
        
        {error && (
          <View style={styles.errorContainer}>
            <Text style={styles.errorText}>{error}</Text>
            <TouchableOpacity style={styles.retryButton} onPress={onRefresh}>
              <Text style={styles.retryButtonText}>{t('retry')}</Text>
            </TouchableOpacity>
          </View>
        )}
      </View>
    );
  };

  // Renderizado principal del componente
  if (viewMode === 'list') {
    return (
      <>
        <FlatList
          data={getFilteredActivities()}
          keyExtractor={(item) => item._id}
          renderItem={renderActivityItem}
          ItemSeparatorComponent={renderSeparator}
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
          }
          onEndReached={loadMore}
          onEndReachedThreshold={0.5}
          ListHeaderComponent={renderHeader}
          ListEmptyComponent={
            loading ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" color="#4A90E2" />
                <Text style={styles.loadingText}>{t('loading')}</Text>
              </View>
            ) : (
              <Text style={styles.emptyText}>
                {t('noActivities')}
              </Text>
            )
          }
          ListFooterComponent={
            pagination.currentPage < pagination.pages && !loading ? (
              <TouchableOpacity style={styles.loadMoreButton} onPress={loadMore}>
                <Text style={styles.loadMoreButtonText}>{t('loadMore')}</Text>
              </TouchableOpacity>
            ) : pagination.currentPage > 1 && loading ? (
              <View style={styles.loadingMoreContainer}>
                <ActivityIndicator size="small" color="#4A90E2" />
                <Text style={styles.loadingMoreText}>{t('loadingMore')}</Text>
              </View>
            ) : null
          }
          contentContainerStyle={styles.listContentContainer}
        />
        {renderMapModal()}
      </>
    );
  } else {
    return (
      <>
        <SectionList
          sections={getGroupedActivities()}
          keyExtractor={(item) => item._id}
          renderItem={renderActivityItem}
          renderSectionHeader={renderSectionHeader}
          ItemSeparatorComponent={renderSeparator}
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
          }
          onEndReached={loadMore}
          onEndReachedThreshold={0.5}
          ListHeaderComponent={renderHeader}
          ListEmptyComponent={
            loading ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" color="#4A90E2" />
                <Text style={styles.loadingText}>{t('loading')}</Text>
              </View>
            ) : (
              <Text style={styles.emptyText}>
                {t('noActivities')}
              </Text>
            )
          }
          ListFooterComponent={
            pagination.currentPage < pagination.pages && !loading ? (
              <TouchableOpacity style={styles.loadMoreButton} onPress={loadMore}>
                <Text style={styles.loadMoreButtonText}>{t('loadMore')}</Text>
              </TouchableOpacity>
            ) : pagination.currentPage > 1 && loading ? (
              <View style={styles.loadingMoreContainer}>
                <ActivityIndicator size="small" color="#4A90E2" />
                <Text style={styles.loadingMoreText}>{t('loadingMore')}</Text>
              </View>
            ) : null
          }
          contentContainerStyle={styles.listContentContainer}
        />
        {renderMapModal()}
      </>
    );
  }
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#2e2e2e',
    padding: 16,
  },
  // Estilos para el botón del mapa
  mapButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#42a5f5',
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
    marginTop: 8,
    alignSelf: 'flex-start',
  },
  mapButtonText: {
    color: '#fff3e5',
    fontSize: Math.min(width * 0.03, 12),
    marginLeft: 4,
    fontWeight: '500',
  },
  // Estilos para el modal del mapa
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContent: {
    width: '90%',
    maxHeight: height * 0.8,
    backgroundColor: '#1c1c1c',
    borderRadius: 15,
    padding: 16,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  modalTitle: {
    fontSize: Math.min(width * 0.05, 18),
    fontWeight: 'bold',
    color: '#fff3e5',
  },
  modalDescription: {
    fontSize: Math.min(width * 0.04, 16),
    color: '#ffffff',
    marginBottom: 8,
  },
  modalCoordinates: {
    fontSize: Math.min(width * 0.035, 14),
    color: '#42a5f5',
    marginBottom: 8,
    fontWeight: '500',
  },
  modalDateTime: {
    fontSize: Math.min(width * 0.03, 12),
    color: '#ffffff',
    opacity: 0.6,
    marginBottom: 15,
  },
  map: {
    width: '100%',
    height: 250,
    borderRadius: 10,
    marginBottom: 15,
  },
  openMapsButton: {
    backgroundColor: '#42a5f5',
    padding: 12,
    borderRadius: 10,
    alignItems: 'center',
  },
  openMapsButtonText: {
    color: '#fff3e5',
    fontWeight: 'bold',
    fontSize: Math.min(width * 0.04, 16),
  },
  header: {
    marginTop: 15,
    marginBottom: 16,
  },
  title: {
    fontSize: Math.min(width * 0.06, 24),
    fontWeight: 'bold',
    color: '#fff3e5',
    marginBottom: 4,
  },
  subtitle: {
    fontSize: Math.min(width * 0.035, 14),
    color: '#ffffff',
    opacity: 0.7,
  },
  // Estilos para los filtros
  filterContainer: {
    flexDirection: 'row',
    marginBottom: 16,
    flexWrap: 'wrap',
  },
  filterButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 15,
    backgroundColor: '#1c1c1c',
    marginRight: 8,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: 'rgba(255, 243, 229, 0.2)',
  },
  filterButtonActive: {
    backgroundColor: '#fff3e5',
    borderColor: '#fff3e5',
  },
  filterButtonText: {
    fontSize: Math.min(width * 0.035, 14),
    color: '#fff3e5',
    marginLeft: 4,
  },
  filterButtonTextActive: {
    color: '#2e2e2e',
  },
  // Estilos para el filtro de tiempo
  timeFilterContainer: {
    marginBottom: 16,
  },
  timeFilterLabel: {
    fontSize: Math.min(width * 0.035, 14),
    color: '#fff3e5',
    marginBottom: 8,
    fontWeight: 'bold',
  },
  timeFilterButtonsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  timeFilterButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 15,
    backgroundColor: '#1c1c1c',
    marginRight: 8,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: 'rgba(255, 243, 229, 0.2)',
  },
  timeFilterButtonActive: {
    backgroundColor: '#42a5f5',
    borderColor: '#42a5f5',
  },
  timeFilterButtonText: {
    fontSize: Math.min(width * 0.03, 12),
    color: '#fff3e5',
  },
  timeFilterButtonTextActive: {
    color: '#fff3e5',
    fontWeight: 'bold',
  },
  // Estilos para los modos de vista
  viewModeContainer: {
    flexDirection: 'row',
    marginBottom: 16,
  },
  viewModeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 15,
    backgroundColor: '#1c1c1c',
    marginRight: 8,
    borderWidth: 1,
    borderColor: 'rgba(255, 243, 229, 0.2)',
  },
  viewModeButtonActive: {
    backgroundColor: '#fff3e5',
    borderColor: '#fff3e5',
  },
  viewModeButtonText: {
    fontSize: Math.min(width * 0.035, 14),
    color: '#fff3e5',
    marginLeft: 4,
  },
  viewModeButtonTextActive: {
    color: '#2e2e2e',
  },
  // Estilos para las secciones (agrupación por usuario)
  sectionHeader: {
    backgroundColor: '#1c1c1c',
    padding: 12,
    borderRadius: 15,
    marginVertical: 8,
    borderWidth: 1,
    borderColor: 'rgba(255, 243, 229, 0.2)',
  },
  sectionHeaderText: {
    fontSize: Math.min(width * 0.04, 16),
    fontWeight: 'bold',
    color: '#fff3e5',
  },
  // Estilos para los elementos de actividad
  activityItem: {
    flexDirection: 'row',
    backgroundColor: '#1c1c1c',
    borderRadius: 15,
    padding: 12,
    marginBottom: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    borderWidth: 1,
    borderColor: 'rgba(255, 243, 229, 0.1)',
  },
  activityIconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  activityContent: {
    flex: 1,
  },
  activityHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  activityType: {
    fontSize: Math.min(width * 0.04, 16),
    fontWeight: 'bold',
    color: '#fff3e5',
  },
  activityTime: {
    fontSize: Math.min(width * 0.035, 14),
    color: '#ffffff',
    opacity: 0.7,
  },
  userName: {
    fontSize: Math.min(width * 0.035, 14),
    fontWeight: 'bold',
    color: '#fff3e5',
    marginBottom: 4,
  },
  activityDescription: {
    fontSize: Math.min(width * 0.035, 14),
    color: '#ffffff',
    opacity: 0.9,
    marginVertical: 4,
  },
  activityDateTime: {
    fontSize: Math.min(width * 0.03, 12),
    color: '#ffffff',
    opacity: 0.6,
    marginTop: 4,
  },
  activityDuration: {
    fontSize: Math.min(width * 0.03, 12),
    color: '#fff3e5',
    marginTop: 4,
  },
  separator: {
    height: 8,
  },
  // Estilos para estados de carga y error
  loadingContainer: {
    padding: 24,
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 8,
    fontSize: Math.min(width * 0.035, 14),
    color: '#ffffff',
    opacity: 0.7,
  },
  emptyText: {
    padding: 24,
    fontSize: Math.min(width * 0.04, 16),
    color: '#ffffff',
    opacity: 0.7,
    textAlign: 'center',
  },
  errorContainer: {
    padding: 16,
    backgroundColor: 'rgba(211, 47, 47, 0.2)',
    borderRadius: 15,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: 'rgba(211, 47, 47, 0.3)',
  },
  errorText: {
    fontSize: Math.min(width * 0.035, 14),
    color: '#ff5252',
    marginBottom: 8,
  },
  retryButton: {
    backgroundColor: '#1c1c1c',
    padding: 10,
    borderRadius: 15,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 243, 229, 0.2)',
  },
  retryButtonText: {
    color: '#fff3e5',
    fontSize: Math.min(width * 0.035, 14),
    fontWeight: 'bold',
  },
  loadMoreButton: {
    backgroundColor: '#1c1c1c',
    padding: 12,
    borderRadius: 15,
    alignItems: 'center',
    marginVertical: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 243, 229, 0.2)',
  },
  loadMoreButtonText: {
    color: '#fff3e5',
    fontSize: Math.min(width * 0.035, 14),
    fontWeight: 'bold',
  },
  loadingMoreContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  loadingMoreText: {
    marginLeft: 8,
    fontSize: Math.min(width * 0.035, 14),
    color: '#ffffff',
    opacity: 0.7,
  },
  listContentContainer: {
    paddingHorizontal: 16,
    paddingBottom: 16,
  },
  loader: {
    marginVertical: 10,
  },
});

export default AdminActivityList;
